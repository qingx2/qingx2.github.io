<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Maverick</title>
<meta name="keywords" content="">
<meta name="description" content="Learn Regex 转载: LEARN REGEX
什么是正则表达式？ 正则表达式是一组由字母和符号组成的特殊文本，它可以用来从文本中找出满足你想要的格式的句子。
一个正则表达式是一种从左到右匹配主体字符串的模式。 “Regular expression”这个词比较拗口，我们常使用缩写的术语“regex”或“regexp”。 正则表达式可以从一个基础字符串中根据一定的匹配模式替换文本中的字符串、验证表单、提取字符串等等。
想象你正在写一个应用，然后你想设定一个用户命名的规则，让用户名包含字符、数字、下划线和连字符，以及限制字符的个数，好让名字看起来没那么丑。 我们使用以下正则表达式来验证一个用户名：
以上的正则表达式可以接受 john_doe、jo-hn_doe、john12_as。 但不匹配Jo，因为它包含了大写的字母而且太短了。
目录 1. 基本匹配 2. 元字符 2.1 点运算符 . 2.2 字符集 2.2.1 否定字符集 2.3 重复次数 2.3.1 * 号 2.3.2 &#43; 号 2.3.3 ? 号 2.4 {} 号 2.5 (&hellip;) 特征标群 2.6 | 或运算符 2.7 转码特殊字符 2.8 锚点 2.8.1 ^ 号 2.8.2 $ 号 3. 简写字符集 4. 零宽度断言(前后预查) 4.1 ?=&hellip; 正先行断言 4.2 ?!&hellip; 负先行断言 4.3 ?&lt;= &hellip; 正后发断言 4.">
<meta name="author" content="">
<link rel="canonical" href="https://qingx2.github.io/post/learn-regex/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.bccfefac377bc340f06c260aed1bddf49a4354816d7c570d6aac75a997986c95.css" integrity="sha256-vM/vrDd7w0DwbCYK7Rvd9JpDVIFtfFcNaqx1qZeYbJU=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://qingx2.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://qingx2.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://qingx2.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://qingx2.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://qingx2.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="" />
<meta property="og:description" content="Learn Regex 转载: LEARN REGEX
什么是正则表达式？ 正则表达式是一组由字母和符号组成的特殊文本，它可以用来从文本中找出满足你想要的格式的句子。
一个正则表达式是一种从左到右匹配主体字符串的模式。 “Regular expression”这个词比较拗口，我们常使用缩写的术语“regex”或“regexp”。 正则表达式可以从一个基础字符串中根据一定的匹配模式替换文本中的字符串、验证表单、提取字符串等等。
想象你正在写一个应用，然后你想设定一个用户命名的规则，让用户名包含字符、数字、下划线和连字符，以及限制字符的个数，好让名字看起来没那么丑。 我们使用以下正则表达式来验证一个用户名：
以上的正则表达式可以接受 john_doe、jo-hn_doe、john12_as。 但不匹配Jo，因为它包含了大写的字母而且太短了。
目录 1. 基本匹配 2. 元字符 2.1 点运算符 . 2.2 字符集 2.2.1 否定字符集 2.3 重复次数 2.3.1 * 号 2.3.2 &#43; 号 2.3.3 ? 号 2.4 {} 号 2.5 (&hellip;) 特征标群 2.6 | 或运算符 2.7 转码特殊字符 2.8 锚点 2.8.1 ^ 号 2.8.2 $ 号 3. 简写字符集 4. 零宽度断言(前后预查) 4.1 ?=&hellip; 正先行断言 4.2 ?!&hellip; 负先行断言 4.3 ?&lt;= &hellip; 正后发断言 4." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://qingx2.github.io/post/learn-regex/" /><meta property="article:section" content="post" />



<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content=""/>
<meta name="twitter:description" content="Learn Regex 转载: LEARN REGEX
什么是正则表达式？ 正则表达式是一组由字母和符号组成的特殊文本，它可以用来从文本中找出满足你想要的格式的句子。
一个正则表达式是一种从左到右匹配主体字符串的模式。 “Regular expression”这个词比较拗口，我们常使用缩写的术语“regex”或“regexp”。 正则表达式可以从一个基础字符串中根据一定的匹配模式替换文本中的字符串、验证表单、提取字符串等等。
想象你正在写一个应用，然后你想设定一个用户命名的规则，让用户名包含字符、数字、下划线和连字符，以及限制字符的个数，好让名字看起来没那么丑。 我们使用以下正则表达式来验证一个用户名：
以上的正则表达式可以接受 john_doe、jo-hn_doe、john12_as。 但不匹配Jo，因为它包含了大写的字母而且太短了。
目录 1. 基本匹配 2. 元字符 2.1 点运算符 . 2.2 字符集 2.2.1 否定字符集 2.3 重复次数 2.3.1 * 号 2.3.2 &#43; 号 2.3.3 ? 号 2.4 {} 号 2.5 (&hellip;) 特征标群 2.6 | 或运算符 2.7 转码特殊字符 2.8 锚点 2.8.1 ^ 号 2.8.2 $ 号 3. 简写字符集 4. 零宽度断言(前后预查) 4.1 ?=&hellip; 正先行断言 4.2 ?!&hellip; 负先行断言 4.3 ?&lt;= &hellip; 正后发断言 4."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://qingx2.github.io/post/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "",
      "item": "https://qingx2.github.io/post/learn-regex/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "",
  "name": "",
  "description": "Learn Regex 转载: LEARN REGEX\n什么是正则表达式？ 正则表达式是一组由字母和符号组成的特殊文本，它可以用来从文本中找出满足你想要的格式的句子。\n一个正则表达式是一种从左到右匹配主体字符串的模式。 “Regular expression”这个词比较拗口，我们常使用缩写的术语“regex”或“regexp”。 正则表达式可以从一个基础字符串中根据一定的匹配模式替换文本中的字符串、验证表单、提取字符串等等。\n想象你正在写一个应用，然后你想设定一个用户命名的规则，让用户名包含字符、数字、下划线和连字符，以及限制字符的个数，好让名字看起来没那么丑。 我们使用以下正则表达式来验证一个用户名：\n以上的正则表达式可以接受 john_doe、jo-hn_doe、john12_as。 但不匹配Jo，因为它包含了大写的字母而且太短了。\n目录 1. 基本匹配 2. 元字符 2.1 点运算符 . 2.2 字符集 2.2.1 否定字符集 2.3 重复次数 2.3.1 * 号 2.3.2 + 号 2.3.3 ? 号 2.4 {} 号 2.5 (\u0026hellip;) 特征标群 2.6 | 或运算符 2.7 转码特殊字符 2.8 锚点 2.8.1 ^ 号 2.8.2 $ 号 3. 简写字符集 4. 零宽度断言(前后预查) 4.1 ?=\u0026hellip; 正先行断言 4.2 ?!\u0026hellip; 负先行断言 4.3 ?\u0026lt;= \u0026hellip; 正后发断言 4.",
  "keywords": [
    
  ],
  "articleBody": "Learn Regex 转载: LEARN REGEX\n什么是正则表达式？ 正则表达式是一组由字母和符号组成的特殊文本，它可以用来从文本中找出满足你想要的格式的句子。\n一个正则表达式是一种从左到右匹配主体字符串的模式。 “Regular expression”这个词比较拗口，我们常使用缩写的术语“regex”或“regexp”。 正则表达式可以从一个基础字符串中根据一定的匹配模式替换文本中的字符串、验证表单、提取字符串等等。\n想象你正在写一个应用，然后你想设定一个用户命名的规则，让用户名包含字符、数字、下划线和连字符，以及限制字符的个数，好让名字看起来没那么丑。 我们使用以下正则表达式来验证一个用户名：\n以上的正则表达式可以接受 john_doe、jo-hn_doe、john12_as。 但不匹配Jo，因为它包含了大写的字母而且太短了。\n目录 1. 基本匹配 2. 元字符 2.1 点运算符 . 2.2 字符集 2.2.1 否定字符集 2.3 重复次数 2.3.1 * 号 2.3.2 + 号 2.3.3 ? 号 2.4 {} 号 2.5 (…) 特征标群 2.6 | 或运算符 2.7 转码特殊字符 2.8 锚点 2.8.1 ^ 号 2.8.2 $ 号 3. 简写字符集 4. 零宽度断言(前后预查) 4.1 ?=… 正先行断言 4.2 ?!… 负先行断言 4.3 ?\u003c= … 正后发断言 4.4 ?\u003c!… 负后发断言 5. 标志 5.1 忽略大小写（Case Insensitive） 5.2 全局搜索（Global search） 5.3 多行修饰符（Multiline） 额外补充 贡献 许可证 1. 基本匹配 正则表达式其实就是在执行搜索时的格式，它由一些字母和数字组合而成。 例如：一个正则表达式 the，它表示一个规则：由字母t开始，接着是h，再接着是e。\n在线练习\n正则表达式123匹配字符串123。它逐个字符的与输入的正则表达式做比较。\n正则表达式是大小写敏感的，所以The不会匹配the。\n在线练习\n2. 元字符 正则表达式主要依赖于元字符。 元字符不代表他们本身的字面意思，他们都有特殊的含义。一些元字符写在方括号中的时候有一些特殊的意思。以下是一些元字符的介绍：\n元字符 描述 . 句号匹配任意单个字符除了换行符。 [ ] 字符种类。匹配方括号内的任意字符。 [^ ] 否定的字符种类。匹配除了方括号里的任意字符 * 匹配\u003e=0个重复的在*号之前的字符。 + 匹配\u003e=1个重复的+号前的字符。 ? 标记?之前的字符为可选. {n,m} 匹配num个大括号之前的字符或字符集 (n \u003c= num \u003c= m). (xyz) 字符集，匹配与 xyz 完全相等的字符串. | 或运算符，匹配符号前或后的字符. \\ 转义字符,用于匹配一些保留的字符 [ ] ( ) { } . * + ? ^ $ \\ | ^ 从开始行开始匹配. $ 从末端开始匹配. 2.1 点运算符 . .是元字符中最简单的例子。 .匹配任意单个字符，但不匹配换行符。 例如，表达式.ar匹配一个任意字符后面跟着是a和r的字符串。\n在线练习\n2.2 字符集 字符集也叫做字符类。 方括号用来指定一个字符集。 在方括号中使用连字符来指定字符集的范围。 在方括号中的字符集不关心顺序。 例如，表达式[Tt]he 匹配 the 和 The。\n在线练习\n方括号的句号就表示句号。 表达式 ar[.] 匹配 ar.字符串\n在线练习\n2.2.1 否定字符集 一般来说 ^ 表示一个字符串的开头，但它用在一个方括号的开头的时候，它表示这个字符集是否定的。 例如，表达式[^c]ar 匹配一个后面跟着ar的除了c的任意字符。\n在线练习\n2.3 重复次数 后面跟着元字符 +，* or ? 的，用来指定匹配子模式的次数。 这些元字符在不同的情况下有着不同的意思。\n2.3.1 * 号 *号匹配 在*之前的字符出现大于等于0次。 例如，表达式 a* 匹配0或更多个以a开头的字符。表达式[a-z]* 匹配一个行中所有以小写字母开头的字符串。\n在线练习\n*字符和.字符搭配可以匹配所有的字符.*。 *和表示匹配空格的符号\\s连起来用，如表达式\\s*cat\\s*匹配0或更多个空格开头和0或更多个空格结尾的cat字符串。\n在线练习\n2.3.2 + 号 +号匹配+号之前的字符出现 \u003e=1 次。 例如表达式c.+t 匹配以首字母c开头以t结尾，中间跟着至少一个字符的字符串。\n在线练习\n2.3.3 ? 号 在正则表达式中元字符 ? 标记在符号前面的字符为可选，即出现 0 或 1 次。 例如，表达式 [T]?he 匹配字符串 he 和 The。\n在线练习\n在线练习\n2.4 {} 号 在正则表达式中 {} 是一个量词，常用来限定一个或一组字符可以重复出现的次数。 例如， 表达式 [0-9]{2,3} 匹配最少 2 位最多 3 位 0~9 的数字。\n在线练习\n我们可以省略第二个参数。 例如，[0-9]{2,} 匹配至少两位 0~9 的数字。\n在线练习\n如果逗号也省略掉则表示重复固定的次数。 例如，[0-9]{3} 匹配3位数字\n在线练习\n2.5 (...) 特征标群 特征标群是一组写在 (...) 中的子模式。(...) 中包含的内容将会被看成一个整体，和数学中小括号（ ）的作用相同。例如, 表达式 (ab)* 匹配连续出现 0 或更多个 ab。如果没有使用 (...) ，那么表达式 ab* 将匹配连续出现 0 或更多个 b 。再比如之前说的 {} 是用来表示前面一个字符出现指定次数。但如果在 {} 前加上特征标群 (...) 则表示整个标群内的字符重复 N 次。\n我们还可以在 () 中用或字符 | 表示或。例如，(c|g|p)ar 匹配 car 或 gar 或 par.\n在线练习\n2.6 | 或运算符 或运算符就表示或，用作判断条件。\n例如 (T|t)he|car 匹配 (T|t)he 或 car。\n在线练习\n2.7 转码特殊字符 反斜线 \\ 在表达式中用于转码紧跟其后的字符。用于指定 { } [ ] / \\ + * . $ ^ | ? 这些特殊字符。如果想要匹配这些特殊字符则要在其前面加上反斜线 \\。\n例如 . 是用来匹配除换行符外的所有字符的。如果想要匹配句子中的 . 则要写成 \\. 以下这个例子 \\.?是选择性匹配.\n在线练习\n2.8 锚点 在正则表达式中，想要匹配指定开头或结尾的字符串就要使用到锚点。^ 指定开头，$ 指定结尾。\n2.8.1 ^ 号 ^ 用来检查匹配的字符串是否在所匹配字符串的开头。\n例如，在 abc 中使用表达式 ^a 会得到结果 a。但如果使用 ^b 将匹配不到任何结果。因为在字符串 abc 中并不是以 b 开头。\n例如，^(T|t)he 匹配以 The 或 the 开头的字符串。\n在线练习\n在线练习\n2.8.2 $ 号 同理于 ^ 号，$ 号用来匹配字符是否是最后一个。\n例如，(at\\.)$ 匹配以 at. 结尾的字符串。\n在线练习\n在线练习\n3. 简写字符集 正则表达式提供一些常用的字符集简写。如下:\n简写 描述 . 除换行符外的所有字符 \\w 匹配所有字母数字，等同于 [a-zA-Z0-9_] \\W 匹配所有非字母数字，即符号，等同于： [^\\w] \\d 匹配数字： [0-9] \\D 匹配非数字： [^\\d] \\s 匹配所有空格字符，等同于： [\\t\\n\\f\\r\\p{Z}] \\S 匹配所有非空格字符： [^\\s] \\f 匹配一个换页符 \\n 匹配一个换行符 \\r 匹配一个回车符 \\t 匹配一个制表符 \\v 匹配一个垂直制表符 \\p 匹配 CR/LF（等同于 \\r\\n），用来匹配 DOS 行终止符 4. 零宽度断言（前后预查） 先行断言和后发断言（合称 lookaround）都属于非捕获组（用于匹配模式，但不包括在匹配列表中）。当我们需要一个模式的前面或后面有另一个特定的模式时，就可以使用它们。\n例如，我们希望从下面的输入字符串 $4.44 和 $10.88 中获得所有以 $ 字符开头的数字，我们将使用以下的正则表达式 (?\u003c=\\$)[0-9\\.]*。意思是：获取所有包含 . 并且前面是 $ 的数字。\n零宽度断言如下：\n符号 描述 ?= 正先行断言-存在 ?! 负先行断言-排除 ?\u003c= 正后发断言-存在 ?\u003c! 负后发断言-排除 4.1 ?=... 正先行断言 ?=... 正先行断言，表示第一部分表达式之后必须跟着 ?=...定义的表达式。\n返回结果只包含满足匹配条件的第一部分表达式。 定义一个正先行断言要使用 ()。在括号内部使用一个问号和等号： (?=...)。\n正先行断言的内容写在括号中的等号后面。 例如，表达式 (T|t)he(?=\\sfat) 匹配 The 和 the，在括号中我们又定义了正先行断言 (?=\\sfat) ，即 The 和 the 后面紧跟着 (空格)fat。\n在线练习\n4.2 ?!... 负先行断言 负先行断言 ?! 用于筛选所有匹配结果，筛选条件为 其后不跟随着断言中定义的格式。 正先行断言 定义和 负先行断言 一样，区别就是 = 替换成 ! 也就是 (?!...)。\n表达式 (T|t)he(?!\\sfat) 匹配 The 和 the，且其后不跟着 (空格)fat。\n在线练习\n4.3 ?\u003c= ... 正后发断言 正后发断言 记作(?\u003c=...) 用于筛选所有匹配结果，筛选条件为 其前跟随着断言中定义的格式。 例如，表达式 (?\u003c=(T|t)he\\s)(fat|mat) 匹配 fat 和 mat，且其前跟着 The 或 the。\n在线练习\n4.4 ?\u003c!... 负后发断言 负后发断言 记作 (?\u003c!...) 用于筛选所有匹配结果，筛选条件为 其前不跟随着断言中定义的格式。 例如，表达式 (?\u003c!(T|t)he\\s)(cat) 匹配 cat，且其前不跟着 The 或 the。\n在线练习\n5. 标志 标志也叫模式修正符，因为它可以用来修改表达式的搜索结果。 这些标志可以任意的组合使用，它也是整个正则表达式的一部分。\n标志 描述 i 忽略大小写。 g 全局搜索。 m 多行修饰符：锚点元字符 ^ $ 工作范围在每行的起始。 5.1 忽略大小写 (Case Insensitive) 修饰语 i 用于忽略大小写。 例如，表达式 /The/gi 表示在全局搜索 The，在后面的 i 将其条件修改为忽略大小写，则变成搜索 the 和 The，g 表示全局搜索。\n在线练习\n在线练习\n5.2 全局搜索 (Global search) 修饰符 g 常用于执行一个全局搜索匹配，即（不仅仅返回第一个匹配的，而是返回全部）。 例如，表达式 /.(at)/g 表示搜索 任意字符（除了换行）+ at，并返回全部结果。\n在线练习\n在线练习\n5.3 多行修饰符 (Multiline) 多行修饰符 m 常用于执行一个多行匹配。\n像之前介绍的 (^,$) 用于检查格式是否是在待检测字符串的开头或结尾。但我们如果想要它在每行的开头和结尾生效，我们需要用到多行修饰符 m。\n例如，表达式 /at(.)?$/gm 表示小写字符 a 后跟小写字符 t ，末尾可选除换行符外任意字符。根据 m 修饰符，现在表达式匹配每行的结尾。\n在线练习\n在线练习\n6. 贪婪匹配与惰性匹配 (Greedy vs lazy matching) 正则表达式默认采用贪婪匹配模式，在该模式下意味着会匹配尽可能长的子串。我们可以使用 ? 将贪婪匹配模式转化为惰性匹配模式。\n在线练习\n在线练习\n贡献 报告问题 开放合并请求 传播此文档 直接和我联系 ziishaned@gmail.com 或 许可证 MIT © Zeeshan Ahmad\n",
  "wordCount" : "626",
  "inLanguage": "en",
  "datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://qingx2.github.io/post/learn-regex/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Maverick",
    "logo": {
      "@type": "ImageObject",
      "url": "https://qingx2.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://qingx2.github.io/" accesskey="h" title="Maverick (Alt + H)">Maverick</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      
    </h1>
    <div class="post-meta">

</div>
  </header> 
  <div class="post-content"><h1 id="learn-regex">Learn Regex<a hidden class="anchor" aria-hidden="true" href="#learn-regex">#</a></h1>
<blockquote>
<p>转载: <a href="https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md">LEARN REGEX</a></p>
</blockquote>
<h2 id="什么是正则表达式">什么是正则表达式？<a hidden class="anchor" aria-hidden="true" href="#什么是正则表达式">#</a></h2>
<p><a href="https://gum.co/learn-regex"><img loading="lazy" src="https://img.shields.io/badge/-Download%20PDF%20-0a0a0a.svg?style=flat&amp;colorA=0a0a0a" alt=""  />
</a></p>
<blockquote>
<p>正则表达式是一组由字母和符号组成的特殊文本，它可以用来从文本中找出满足你想要的格式的句子。</p>
</blockquote>
<p>一个正则表达式是一种从左到右匹配主体字符串的模式。
“Regular expression”这个词比较拗口，我们常使用缩写的术语“regex”或“regexp”。
正则表达式可以从一个基础字符串中根据一定的匹配模式替换文本中的字符串、验证表单、提取字符串等等。</p>
<p>想象你正在写一个应用，然后你想设定一个用户命名的规则，让用户名包含字符、数字、下划线和连字符，以及限制字符的个数，好让名字看起来没那么丑。
我们使用以下正则表达式来验证一个用户名：</p>
<!-- raw HTML omitted -->
<p>以上的正则表达式可以接受 <code>john_doe</code>、<code>jo-hn_doe</code>、<code>john12_as</code>。
但不匹配<code>Jo</code>，因为它包含了大写的字母而且太短了。</p>
<h1 id="目录">目录<a hidden class="anchor" aria-hidden="true" href="#目录">#</a></h1>
<ul>
<li><a href="#1-%E5%9F%BA%E6%9C%AC%E5%8C%B9%E9%85%8D">1. 基本匹配</a></li>
<li><a href="#2-%E5%85%83%E5%AD%97%E7%AC%A6">2. 元字符</a>
<ul>
<li><a href="#21-%E7%82%B9%E8%BF%90%E7%AE%97%E7%AC%A6-">2.1 点运算符 .</a></li>
<li><a href="#22-%E5%AD%97%E7%AC%A6%E9%9B%86">2.2 字符集</a>
<ul>
<li><a href="#221-%E5%90%A6%E5%AE%9A%E5%AD%97%E7%AC%A6%E9%9B%86">2.2.1 否定字符集</a></li>
</ul>
</li>
<li><a href="#23-%E9%87%8D%E5%A4%8D%E6%AC%A1%E6%95%B0">2.3 重复次数</a>
<ul>
<li><a href="#231--%E5%8F%B7">2.3.1 * 号</a></li>
<li><a href="#232--%E5%8F%B7">2.3.2 + 号</a></li>
<li><a href="#233--%E5%8F%B7">2.3.3 ? 号</a></li>
</ul>
</li>
<li><a href="#24--%E5%8F%B7">2.4 {} 号</a></li>
<li><a href="#25--%E7%89%B9%E5%BE%81%E6%A0%87%E7%BE%A4">2.5 (&hellip;) 特征标群</a></li>
<li><a href="#26--%E6%88%96%E8%BF%90%E7%AE%97%E7%AC%A6">2.6 | 或运算符</a></li>
<li><a href="#27-%E8%BD%AC%E7%A0%81%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6">2.7 转码特殊字符</a></li>
<li><a href="#28-%E9%94%9A%E7%82%B9">2.8 锚点</a>
<ul>
<li><a href="#281--%E5%8F%B7">2.8.1 ^ 号</a></li>
<li><a href="#282--%E5%8F%B7">2.8.2 $ 号</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-%E7%AE%80%E5%86%99%E5%AD%97%E7%AC%A6%E9%9B%86">3. 简写字符集</a></li>
<li><a href="#4-%E9%9B%B6%E5%AE%BD%E5%BA%A6%E6%96%AD%E8%A8%80%E5%89%8D%E5%90%8E%E9%A2%84%E6%9F%A5">4. 零宽度断言(前后预查)</a>
<ul>
<li><a href="#41--%E6%AD%A3%E5%85%88%E8%A1%8C%E6%96%AD%E8%A8%80">4.1 ?=&hellip; 正先行断言</a></li>
<li><a href="#42--%E8%B4%9F%E5%85%88%E8%A1%8C%E6%96%AD%E8%A8%80">4.2 ?!&hellip; 负先行断言</a></li>
<li><a href="#43---%E6%AD%A3%E5%90%8E%E5%8F%91%E6%96%AD%E8%A8%80">4.3 ?&lt;= &hellip; 正后发断言</a></li>
<li><a href="#44--%E8%B4%9F%E5%90%8E%E5%8F%91%E6%96%AD%E8%A8%80">4.4 ?&lt;!&hellip; 负后发断言</a></li>
</ul>
</li>
<li><a href="#5-%E6%A0%87%E5%BF%97">5. 标志</a>
<ul>
<li><a href="#51-%E5%BF%BD%E7%95%A5%E5%A4%A7%E5%B0%8F%E5%86%99-case-insensitive">5.1 忽略大小写（Case Insensitive）</a></li>
<li><a href="#52-%E5%85%A8%E5%B1%80%E6%90%9C%E7%B4%A2-global-search">5.2 全局搜索（Global search）</a></li>
<li><a href="#53-%E5%A4%9A%E8%A1%8C%E4%BF%AE%E9%A5%B0%E7%AC%A6-multiline">5.3 多行修饰符（Multiline）</a></li>
</ul>
</li>
<li><a href="#%E9%A2%9D%E5%A4%96%E8%A1%A5%E5%85%85">额外补充</a></li>
<li><a href="#%E8%B4%A1%E7%8C%AE">贡献</a></li>
<li><a href="#%E8%AE%B8%E5%8F%AF%E8%AF%81">许可证</a></li>
</ul>
<h2 id="1-基本匹配">1. 基本匹配<a hidden class="anchor" aria-hidden="true" href="#1-基本匹配">#</a></h2>
<p>正则表达式其实就是在执行搜索时的格式，它由一些字母和数字组合而成。
例如：一个正则表达式 <code>the</code>，它表示一个规则：由字母<code>t</code>开始，接着是<code>h</code>，再接着是<code>e</code>。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><a href="https://regex101.com/r/dmRygT/1">在线练习</a></p>
<p>正则表达式<code>123</code>匹配字符串<code>123</code>。它逐个字符的与输入的正则表达式做比较。</p>
<p>正则表达式是大小写敏感的，所以<code>The</code>不会匹配<code>the</code>。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><a href="https://regex101.com/r/1paXsy/1">在线练习</a></p>
<h2 id="2-元字符">2. 元字符<a hidden class="anchor" aria-hidden="true" href="#2-元字符">#</a></h2>
<p>正则表达式主要依赖于元字符。
元字符不代表他们本身的字面意思，他们都有特殊的含义。一些元字符写在方括号中的时候有一些特殊的意思。以下是一些元字符的介绍：</p>
<table>
<thead>
<tr>
<th style="text-align:center">元字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">.</td>
<td>句号匹配任意单个字符除了换行符。</td>
</tr>
<tr>
<td style="text-align:center">[ ]</td>
<td>字符种类。匹配方括号内的任意字符。</td>
</tr>
<tr>
<td style="text-align:center">[^ ]</td>
<td>否定的字符种类。匹配除了方括号里的任意字符</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td>匹配&gt;=0个重复的在*号之前的字符。</td>
</tr>
<tr>
<td style="text-align:center">+</td>
<td>匹配&gt;=1个重复的+号前的字符。</td>
</tr>
<tr>
<td style="text-align:center">?</td>
<td>标记?之前的字符为可选.</td>
</tr>
<tr>
<td style="text-align:center">{n,m}</td>
<td>匹配num个大括号之前的字符或字符集 (n &lt;= num &lt;= m).</td>
</tr>
<tr>
<td style="text-align:center">(xyz)</td>
<td>字符集，匹配与 xyz 完全相等的字符串.</td>
</tr>
<tr>
<td style="text-align:center">|</td>
<td>或运算符，匹配符号前或后的字符.</td>
</tr>
<tr>
<td style="text-align:center">\</td>
<td>转义字符,用于匹配一些保留的字符 <!-- raw HTML omitted -->[ ] ( ) { } . * + ? ^ $ \ |<!-- raw HTML omitted --></td>
</tr>
<tr>
<td style="text-align:center">^</td>
<td>从开始行开始匹配.</td>
</tr>
<tr>
<td style="text-align:center">$</td>
<td>从末端开始匹配.</td>
</tr>
</tbody>
</table>
<h2 id="21-点运算符-">2.1 点运算符 <code>.</code><a hidden class="anchor" aria-hidden="true" href="#21-点运算符-">#</a></h2>
<p><code>.</code>是元字符中最简单的例子。
<code>.</code>匹配任意单个字符，但不匹配换行符。
例如，表达式<code>.ar</code>匹配一个任意字符后面跟着是<code>a</code>和<code>r</code>的字符串。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><a href="https://regex101.com/r/xc9GkU/1">在线练习</a></p>
<h2 id="22-字符集">2.2 字符集<a hidden class="anchor" aria-hidden="true" href="#22-字符集">#</a></h2>
<p>字符集也叫做字符类。
方括号用来指定一个字符集。
在方括号中使用连字符来指定字符集的范围。
在方括号中的字符集不关心顺序。
例如，表达式<code>[Tt]he</code> 匹配 <code>the</code> 和 <code>The</code>。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><a href="https://regex101.com/r/2ITLQ4/1">在线练习</a></p>
<p>方括号的句号就表示句号。
表达式 <code>ar[.]</code> 匹配 <code>ar.</code>字符串</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><a href="https://regex101.com/r/wL3xtE/1">在线练习</a></p>
<h3 id="221-否定字符集">2.2.1 否定字符集<a hidden class="anchor" aria-hidden="true" href="#221-否定字符集">#</a></h3>
<p>一般来说 <code>^</code> 表示一个字符串的开头，但它用在一个方括号的开头的时候，它表示这个字符集是否定的。
例如，表达式<code>[^c]ar</code> 匹配一个后面跟着<code>ar</code>的除了<code>c</code>的任意字符。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><a href="https://regex101.com/r/nNNlq3/1">在线练习</a></p>
<h2 id="23-重复次数">2.3 重复次数<a hidden class="anchor" aria-hidden="true" href="#23-重复次数">#</a></h2>
<p>后面跟着元字符 <code>+</code>，<code>*</code> or <code>?</code> 的，用来指定匹配子模式的次数。
这些元字符在不同的情况下有着不同的意思。</p>
<h3 id="231--号">2.3.1 <code>*</code> 号<a hidden class="anchor" aria-hidden="true" href="#231--号">#</a></h3>
<p><code>*</code>号匹配 在<code>*</code>之前的字符出现<code>大于等于0</code>次。
例如，表达式 <code>a*</code> 匹配0或更多个以a开头的字符。表达式<code>[a-z]*</code> 匹配一个行中所有以小写字母开头的字符串。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><a href="https://regex101.com/r/7m8me5/1">在线练习</a></p>
<p><code>*</code>字符和<code>.</code>字符搭配可以匹配所有的字符<code>.*</code>。
<code>*</code>和表示匹配空格的符号<code>\s</code>连起来用，如表达式<code>\s*cat\s*</code>匹配0或更多个空格开头和0或更多个空格结尾的cat字符串。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><a href="https://regex101.com/r/gGrwuz/1">在线练习</a></p>
<h3 id="232--号">2.3.2 <code>+</code> 号<a hidden class="anchor" aria-hidden="true" href="#232--号">#</a></h3>
<p><code>+</code>号匹配<code>+</code>号之前的字符出现 &gt;=1 次。
例如表达式<code>c.+t</code> 匹配以首字母<code>c</code>开头以<code>t</code>结尾，中间跟着至少一个字符的字符串。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><a href="https://regex101.com/r/Dzf9Aa/1">在线练习</a></p>
<h3 id="233--号">2.3.3 <code>?</code> 号<a hidden class="anchor" aria-hidden="true" href="#233--号">#</a></h3>
<p>在正则表达式中元字符 <code>?</code> 标记在符号前面的字符为可选，即出现 0 或 1 次。
例如，表达式 <code>[T]?he</code> 匹配字符串 <code>he</code> 和 <code>The</code>。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><a href="https://regex101.com/r/cIg9zm/1">在线练习</a></p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><a href="https://regex101.com/r/kPpO2x/1">在线练习</a></p>
<h2 id="24--号">2.4 <code>{}</code> 号<a hidden class="anchor" aria-hidden="true" href="#24--号">#</a></h2>
<p>在正则表达式中 <code>{}</code> 是一个量词，常用来限定一个或一组字符可以重复出现的次数。
例如， 表达式 <code>[0-9]{2,3}</code> 匹配最少 2 位最多 3 位 0~9 的数字。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><a href="https://regex101.com/r/juM86s/1">在线练习</a></p>
<p>我们可以省略第二个参数。
例如，<code>[0-9]{2,}</code> 匹配至少两位 0~9 的数字。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><a href="https://regex101.com/r/Gdy4w5/1">在线练习</a></p>
<p>如果逗号也省略掉则表示重复固定的次数。
例如，<code>[0-9]{3}</code> 匹配3位数字</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><a href="https://regex101.com/r/Sivu30/1">在线练习</a></p>
<h2 id="25--特征标群">2.5 <code>(...)</code> 特征标群<a hidden class="anchor" aria-hidden="true" href="#25--特征标群">#</a></h2>
<p>特征标群是一组写在 <code>(...)</code> 中的子模式。<code>(...)</code> 中包含的内容将会被看成一个整体，和数学中小括号（ ）的作用相同。例如, 表达式 <code>(ab)*</code> 匹配连续出现 0 或更多个 <code>ab</code>。如果没有使用 <code>(...)</code> ，那么表达式 <code>ab*</code> 将匹配连续出现 0 或更多个 <code>b</code> 。再比如之前说的 <code>{}</code> 是用来表示前面一个字符出现指定次数。但如果在 <code>{}</code> 前加上特征标群 <code>(...)</code> 则表示整个标群内的字符重复 N 次。</p>
<p>我们还可以在 <code>()</code> 中用或字符 <code>|</code> 表示或。例如，<code>(c|g|p)ar</code> 匹配 <code>car</code> 或 <code>gar</code> 或 <code>par</code>.</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><a href="https://regex101.com/r/tUxrBG/1">在线练习</a></p>
<h2 id="26--或运算符">2.6 <code>|</code> 或运算符<a hidden class="anchor" aria-hidden="true" href="#26--或运算符">#</a></h2>
<p>或运算符就表示或，用作判断条件。</p>
<p>例如 <code>(T|t)he|car</code> 匹配 <code>(T|t)he</code> 或 <code>car</code>。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><a href="https://regex101.com/r/fBXyX0/1">在线练习</a></p>
<h2 id="27-转码特殊字符">2.7 转码特殊字符<a hidden class="anchor" aria-hidden="true" href="#27-转码特殊字符">#</a></h2>
<p>反斜线 <code>\</code> 在表达式中用于转码紧跟其后的字符。用于指定 <code>{ } [ ] / \ + * . $ ^ | ?</code> 这些特殊字符。如果想要匹配这些特殊字符则要在其前面加上反斜线 <code>\</code>。</p>
<p>例如 <code>.</code> 是用来匹配除换行符外的所有字符的。如果想要匹配句子中的 <code>.</code> 则要写成 <code>\.</code> 以下这个例子 <code>\.?</code>是选择性匹配<code>.</code></p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><a href="https://regex101.com/r/DOc5Nu/1">在线练习</a></p>
<h2 id="28-锚点">2.8 锚点<a hidden class="anchor" aria-hidden="true" href="#28-锚点">#</a></h2>
<p>在正则表达式中，想要匹配指定开头或结尾的字符串就要使用到锚点。<code>^</code> 指定开头，<code>$</code> 指定结尾。</p>
<h3 id="281--号">2.8.1 <code>^</code> 号<a hidden class="anchor" aria-hidden="true" href="#281--号">#</a></h3>
<p><code>^</code> 用来检查匹配的字符串是否在所匹配字符串的开头。</p>
<p>例如，在 <code>abc</code> 中使用表达式 <code>^a</code> 会得到结果 <code>a</code>。但如果使用 <code>^b</code> 将匹配不到任何结果。因为在字符串 <code>abc</code> 中并不是以 <code>b</code> 开头。</p>
<p>例如，<code>^(T|t)he</code> 匹配以 <code>The</code> 或 <code>the</code> 开头的字符串。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><a href="https://regex101.com/r/5ljjgB/1">在线练习</a></p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><a href="https://regex101.com/r/jXrKne/1">在线练习</a></p>
<h3 id="282--号">2.8.2 <code>$</code> 号<a hidden class="anchor" aria-hidden="true" href="#282--号">#</a></h3>
<p>同理于 <code>^</code> 号，<code>$</code> 号用来匹配字符是否是最后一个。</p>
<p>例如，<code>(at\.)$</code> 匹配以 <code>at.</code> 结尾的字符串。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><a href="https://regex101.com/r/y4Au4D/1">在线练习</a></p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><a href="https://regex101.com/r/t0AkOd/1">在线练习</a></p>
<h2 id="3-简写字符集">3. 简写字符集<a hidden class="anchor" aria-hidden="true" href="#3-简写字符集">#</a></h2>
<p>正则表达式提供一些常用的字符集简写。如下:</p>
<table>
<thead>
<tr>
<th style="text-align:center">简写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">.</td>
<td>除换行符外的所有字符</td>
</tr>
<tr>
<td style="text-align:center">\w</td>
<td>匹配所有字母数字，等同于 <code>[a-zA-Z0-9_]</code></td>
</tr>
<tr>
<td style="text-align:center">\W</td>
<td>匹配所有非字母数字，即符号，等同于： <code>[^\w]</code></td>
</tr>
<tr>
<td style="text-align:center">\d</td>
<td>匹配数字： <code>[0-9]</code></td>
</tr>
<tr>
<td style="text-align:center">\D</td>
<td>匹配非数字： <code>[^\d]</code></td>
</tr>
<tr>
<td style="text-align:center">\s</td>
<td>匹配所有空格字符，等同于： <code>[\t\n\f\r\p{Z}]</code></td>
</tr>
<tr>
<td style="text-align:center">\S</td>
<td>匹配所有非空格字符： <code>[^\s]</code></td>
</tr>
<tr>
<td style="text-align:center">\f</td>
<td>匹配一个换页符</td>
</tr>
<tr>
<td style="text-align:center">\n</td>
<td>匹配一个换行符</td>
</tr>
<tr>
<td style="text-align:center">\r</td>
<td>匹配一个回车符</td>
</tr>
<tr>
<td style="text-align:center">\t</td>
<td>匹配一个制表符</td>
</tr>
<tr>
<td style="text-align:center">\v</td>
<td>匹配一个垂直制表符</td>
</tr>
<tr>
<td style="text-align:center">\p</td>
<td>匹配 CR/LF（等同于 <code>\r\n</code>），用来匹配 DOS 行终止符</td>
</tr>
</tbody>
</table>
<h2 id="4-零宽度断言前后预查">4. 零宽度断言（前后预查）<a hidden class="anchor" aria-hidden="true" href="#4-零宽度断言前后预查">#</a></h2>
<p>先行断言和后发断言（合称 lookaround）都属于<strong>非捕获组</strong>（用于匹配模式，但不包括在匹配列表中）。当我们需要一个模式的前面或后面有另一个特定的模式时，就可以使用它们。</p>
<p>例如，我们希望从下面的输入字符串 <code>$4.44</code> 和 <code>$10.88</code> 中获得所有以 <code>$</code> 字符开头的数字，我们将使用以下的正则表达式 <code>(?&lt;=\$)[0-9\.]*</code>。意思是：获取所有包含 <code>.</code> 并且前面是 <code>$</code> 的数字。</p>
<p>零宽度断言如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">?=</td>
<td>正先行断言-存在</td>
</tr>
<tr>
<td style="text-align:center">?!</td>
<td>负先行断言-排除</td>
</tr>
<tr>
<td style="text-align:center">?&lt;=</td>
<td>正后发断言-存在</td>
</tr>
<tr>
<td style="text-align:center">?&lt;!</td>
<td>负后发断言-排除</td>
</tr>
</tbody>
</table>
<h3 id="41--正先行断言">4.1 <code>?=...</code> 正先行断言<a hidden class="anchor" aria-hidden="true" href="#41--正先行断言">#</a></h3>
<p><code>?=...</code> 正先行断言，表示第一部分表达式之后必须跟着 <code>?=...</code>定义的表达式。</p>
<p>返回结果只包含满足匹配条件的第一部分表达式。
定义一个正先行断言要使用 <code>()</code>。在括号内部使用一个问号和等号： <code>(?=...)</code>。</p>
<p>正先行断言的内容写在括号中的等号后面。
例如，表达式 <code>(T|t)he(?=\sfat)</code> 匹配 <code>The</code> 和 <code>the</code>，在括号中我们又定义了正先行断言 <code>(?=\sfat)</code> ，即 <code>The</code> 和 <code>the</code> 后面紧跟着 <code>(空格)fat</code>。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><a href="https://regex101.com/r/IDDARt/1">在线练习</a></p>
<h3 id="42--负先行断言">4.2 <code>?!...</code> 负先行断言<a hidden class="anchor" aria-hidden="true" href="#42--负先行断言">#</a></h3>
<p>负先行断言 <code>?!</code> 用于筛选所有匹配结果，筛选条件为 其后不跟随着断言中定义的格式。
<code>正先行断言</code>  定义和 <code>负先行断言</code> 一样，区别就是 <code>=</code> 替换成 <code>!</code> 也就是 <code>(?!...)</code>。</p>
<p>表达式 <code>(T|t)he(?!\sfat)</code> 匹配 <code>The</code> 和 <code>the</code>，且其后不跟着 <code>(空格)fat</code>。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><a href="https://regex101.com/r/V32Npg/1">在线练习</a></p>
<h3 id="43---正后发断言">4.3 <code>?&lt;= ...</code> 正后发断言<a hidden class="anchor" aria-hidden="true" href="#43---正后发断言">#</a></h3>
<p>正后发断言 记作<code>(?&lt;=...)</code> 用于筛选所有匹配结果，筛选条件为 其前跟随着断言中定义的格式。
例如，表达式 <code>(?&lt;=(T|t)he\s)(fat|mat)</code> 匹配 <code>fat</code> 和 <code>mat</code>，且其前跟着 <code>The</code> 或 <code>the</code>。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><a href="https://regex101.com/r/avH165/1">在线练习</a></p>
<h3 id="44--负后发断言">4.4 <code>?&lt;!...</code> 负后发断言<a hidden class="anchor" aria-hidden="true" href="#44--负后发断言">#</a></h3>
<p>负后发断言 记作 <code>(?&lt;!...)</code> 用于筛选所有匹配结果，筛选条件为 其前不跟随着断言中定义的格式。
例如，表达式 <code>(?&lt;!(T|t)he\s)(cat)</code> 匹配 <code>cat</code>，且其前不跟着 <code>The</code> 或 <code>the</code>。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><a href="https://regex101.com/r/8Efx5G/1">在线练习</a></p>
<h2 id="5-标志">5. 标志<a hidden class="anchor" aria-hidden="true" href="#5-标志">#</a></h2>
<p>标志也叫模式修正符，因为它可以用来修改表达式的搜索结果。
这些标志可以任意的组合使用，它也是整个正则表达式的一部分。</p>
<table>
<thead>
<tr>
<th style="text-align:center">标志</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">i</td>
<td>忽略大小写。</td>
</tr>
<tr>
<td style="text-align:center">g</td>
<td>全局搜索。</td>
</tr>
<tr>
<td style="text-align:center">m</td>
<td>多行修饰符：锚点元字符 <code>^</code> <code>$</code> 工作范围在每行的起始。</td>
</tr>
</tbody>
</table>
<h3 id="51-忽略大小写-case-insensitive">5.1 忽略大小写 (Case Insensitive)<a hidden class="anchor" aria-hidden="true" href="#51-忽略大小写-case-insensitive">#</a></h3>
<p>修饰语 <code>i</code> 用于忽略大小写。
例如，表达式 <code>/The/gi</code> 表示在全局搜索 <code>The</code>，在后面的 <code>i</code> 将其条件修改为忽略大小写，则变成搜索 <code>the</code> 和 <code>The</code>，<code>g</code> 表示全局搜索。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><a href="https://regex101.com/r/dpQyf9/1">在线练习</a></p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><a href="https://regex101.com/r/ahfiuh/1">在线练习</a></p>
<h3 id="52-全局搜索-global-search">5.2 全局搜索 (Global search)<a hidden class="anchor" aria-hidden="true" href="#52-全局搜索-global-search">#</a></h3>
<p>修饰符 <code>g</code> 常用于执行一个全局搜索匹配，即（不仅仅返回第一个匹配的，而是返回全部）。
例如，表达式 <code>/.(at)/g</code> 表示搜索 任意字符（除了换行）+ <code>at</code>，并返回全部结果。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><a href="https://regex101.com/r/jnk6gM/1">在线练习</a></p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><a href="https://regex101.com/r/dO1nef/1">在线练习</a></p>
<h3 id="53-多行修饰符-multiline">5.3 多行修饰符 (Multiline)<a hidden class="anchor" aria-hidden="true" href="#53-多行修饰符-multiline">#</a></h3>
<p>多行修饰符 <code>m</code> 常用于执行一个多行匹配。</p>
<p>像之前介绍的 <code>(^,$)</code> 用于检查格式是否是在待检测字符串的开头或结尾。但我们如果想要它在每行的开头和结尾生效，我们需要用到多行修饰符 <code>m</code>。</p>
<p>例如，表达式 <code>/at(.)?$/gm</code> 表示小写字符 <code>a</code> 后跟小写字符 <code>t</code> ，末尾可选除换行符外任意字符。根据 <code>m</code> 修饰符，现在表达式匹配每行的结尾。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><a href="https://regex101.com/r/hoGMkP/1">在线练习</a></p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><a href="https://regex101.com/r/E88WE2/1">在线练习</a></p>
<h3 id="6-贪婪匹配与惰性匹配-greedy-vs-lazy-matching">6. 贪婪匹配与惰性匹配 (Greedy vs lazy matching)<a hidden class="anchor" aria-hidden="true" href="#6-贪婪匹配与惰性匹配-greedy-vs-lazy-matching">#</a></h3>
<p>正则表达式默认采用贪婪匹配模式，在该模式下意味着会匹配尽可能长的子串。我们可以使用 <code>?</code> 将贪婪匹配模式转化为惰性匹配模式。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><a href="https://regex101.com/r/AyAdgJ/1">在线练习</a></p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><a href="https://regex101.com/r/AyAdgJ/2">在线练习</a></p>
<h2 id="贡献">贡献<a hidden class="anchor" aria-hidden="true" href="#贡献">#</a></h2>
<ul>
<li>报告问题</li>
<li>开放合并请求</li>
<li>传播此文档</li>
<li>直接和我联系 <a href="mailto:ziishaned@gmail.com">ziishaned@gmail.com</a> 或 <a href="https://twitter.com/ziishaned"><img loading="lazy" src="https://img.shields.io/twitter/url/https/twitter.com/ziishaned.svg?style=social&amp;label=Follow%20%40ziishaned" alt="Twitter URL"  />
</a></li>
</ul>
<h2 id="许可证">许可证<a hidden class="anchor" aria-hidden="true" href="#许可证">#</a></h2>
<p>MIT © <a href="https://twitter.com/ziishaned">Zeeshan Ahmad</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://qingx2.github.io/">Maverick</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
